# 第一章 线程安全的对象的生命周期管理

### 进程
进程是系统进行资源分配和调度的基本单位。程序是指令、数据机器组织形式的描述，进程是程序的实体。

### 线程
线程是操作系统能够进行运算调度的最小单位。线程是进程中负责程序执行的执行单元，一个进程至少有一个线程。

### 串行
单线程执行多个任务。

### 并行
多线程执行多任务。

### 多线程
一个进程运行时产生多个线程。

### 线程安全
线程安全是指，在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。<br />
一个线程安全的*class*应该满足下面三个条件：<br />

* 多个线程同时访问时，其表现出正确的行为；
* 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织(*interleaving*)；
* 调用端代码无序额外的同步或其他协调动作；

### 竞态
如果程序运行顺序的改变会影响最终结果,这就是一个竞态条件(race condition)。程序运行顺序的改变会影响最终结果。<br />
对象析构时会出现竞态条件：<br />

* 对象析构时无法确定对象是否正在使用；
* 对象使用时无法确定是否在析构；
* 调用对象的成员函数时怎么知道该对象的析构函数是否已经执行一半；

### 可重入与不可重入
可重入函数，除了栈上面的变量以外，不依赖于任何环境，函数执行的任何时刻都可以被中断，转而执行另一段代码，返回控制时不会出错。<br />
不可重入函数，由于使用了一些系统资源，被中断时可能会出现问题。<br />
**可重入锁**，也叫递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。换一种说法：同一个线程再次进入同步代码时，可以使用自己已获取到的锁。

### RAII
**RAII**是C++语言的一种管理资源、避免泄漏的惯用法。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。
由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。**如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。**

### 线程安全地构造对象
* 不要在构造函数中注册任何回调；
* 不要在构造函数中把*this*指针传给跨线程的对象；
* 即使是构造函数最后一句也不可以；

### 野指针与空悬指针
野指针(wild pointer)就是没有被初始化过的指针。<br />
悬空指针(dangling pointer)是指针最初指向的内存已经被释放了的一种指针。 <br />

## 总结性概述
**线程安全**的类可以通过**同步原语**(*synchronization primitives*)实现，但是对象的析构问题不能由对象自身拥有的*mutex*(互斥器)来保护。对象析构产生的**竞态条件**可以借助*shared_ptr*以及*weak_ptr*完美解决，这也是线程安全的*Observer*模式的必备技术。<br />
根据线程安全的定义，C++标准库中大多数*class*都不是线程安全的。<br />
**MutexLock**封装临界区，一般作为其他类的数据成员。<br />
**MutexLockGuard**封装临界区的进入和退出，一般是栈上对象，作用域与临界区域相等。这两个类都不能拷贝构造和赋值。<br />

* **线程安全的Counter示例**<br />

```
//boost安装sudo权限
class Counter:boost::noncopyable
{
public:
	Counter() : value_(0) {}
	int64_t value() const;
	int64_t getAndIncrease();
	
private:
	int64_t value_;
	mutable MutexLock mutex_;
	/*
	mutalbe的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。
	在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
	我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。
	*/
}

int64_t Counter::Value() const
{
	MutexLockGuard lock(mutex_);
	return value_;
}

int64_t Counter::getAndIncrease()
{
	MutexLockGuard lock(mutex_);
	int64_t ret = value_++;
	return ret;
}
```

如果在对象的构造函数执行期间把*this*指针泄露给了其他的对象，别的线程可能访问该半成品对象，这会导致难以预料的后果。例如：<br />

```
class Foo : public Observer
{
public:
	Foo(Observer *s)
	{
		s->register_(this); //error 非线程安全
	}
	
	virtual void update();
};
```

正确如下：<br />

```
class Foo : public Observer
{
public:
	Foo();
	virtual void update();
	
	//另外定义一个函数，在构造之后执行回调函数的注册工作
	void observe(Observer *s)
	{
		s->register_(this);
	}
};

Foo* pFoo = new Foo;
Observer* s = getSubject();
pFoo->observer(s);	//二段式构造，或直接写s->register(pFoo);
```

二段式构造-------------即构造函数+initialized()。构造函数不必主动抛异常，可根据initialize()的返回值判断是否构造成功。<br />
即使最后一行也不可以泄露this。Foo可能是一个基类，基类先于派生类，构造完Foo::Foo()，还会接着构造派生类，这时，派生的最后一阶的对象还在构造中，仍然不安全。<br />
在单线程中，对象的析构最多需要注意避免**空悬指针**(和野指针)。<br />
在多线程中，对于一般的成员函数而言，要做到线程安全的方法，就是要让他们顺次执行，而不要并发，这一点可通过互斥器临界区。对于一般成员函数，互斥器有效性是不会变化，但是在析构函数中，互斥器会被销毁，从而**破坏**线程安全。<br />

* Mutex是否能保护析构函数 ？<br />

```
//----1----------
Foo::~Foo()
{
	MutexLock lock(mutex_);
	// free internal state
}

//----2-----------
void Foo::update()
{
	MutexLock lock(mutex_);
	// make use of internal state
}

/***extern Foo* x;***/
//----3------------thread A
delete x;
x = NULL;	//helpless

//----4------------thread B
if (x) {
	x->update();
}
```

* 如果要使用相同类型对象的mutex，则可以始终保证按相同的顺序加锁，先锁地址小的，再锁地址大的；<br />






